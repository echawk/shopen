#!/bin/sh

# shopen - a POSIX shell replacement for xdg-open
# Copyright (c) 2021, Ethan Hawk
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# SPDX-License-Identifier: GPL-3.0-or-later

# Directories that contain desktop files
SYSTEM_DESKTOP_FILES_DIR=/usr/share/applications/
USER_DESKTOP_FILES_DIR=${XDG_DATA_HOME:-$HOME/.local/share}/applications/

# The standard configuration file for xdg-open
MIMEAPPSLIST=${XDG_CONFIG_DIR:-$HOME/.config}/mimeapps.list

# These files are tab separated value files, with the first collumn
# being the regular expression, and the second column being the command
# to run. '%M' in the second column is replaced with '$f'.
# This is so that commands can be arbitrarily complex.
REGEXRULESFILE=${XDG_CONFIG_DIR:-$HOME/.config}/shopen/rerules.tsv
MIMERULESFILE=${XDG_CONFIG_DIR:-$HOME/.config}/shopen/mimerules.tsv
# depends: file, grep, cut, sed

for f in "$@"
do
  MIME_TYPE="$(file --mime-type "$f" | cut -d':' -f2 | sed "s/^ //")"

  # if the MIMERULESFILE exists
  [ -e "$MIMERULESFILE" ] && {
  # for every regex rule that is definied the mime rules file
  # shellcheck disable=SC2013
  for mirule in $(grep -v -E "(^#|^$)"  "$MIMERULESFILE" | cut -d'	' -f1)
  do
    # if we have a match
    if printf "%s" "$MIME_TYPE" | grep -q -E "$mirule"
    then
      # construct the execcmd
      execcmd=$(grep -F "${mirule}" "$MIMERULESFILE" \
        | cut -d'	' -f2 \
        | sed \
        "s~%M~\"\$(echo $(printf "%s" "${f}" | base64 -w 0) | base64 -d)\"~g")
      break
    fi
  done
  }

  # if execcmd is length zero
  [ -z "$execcmd" ] && {
  WANTDESKTOPFILE=""
  DESKTOPFILE=""
  # if the mimetype is mentioned in the mimeapps.list
  if grep -q "$MIME_TYPE" "$MIMEAPPSLIST"
  then
    # set our wanted desktop file to be the second field
    WANTDESKTOPFILE=$(grep "$MIME_TYPE" "$MIMEAPPSLIST" | cut -d'=' -f2)
  fi

  for DESKDIR in $USER_DESKTOP_FILES_DIR $SYSTEM_DESKTOP_FILES_DIR
  do
    for deskf in "$DESKDIR"*
    do
      # if we found the desktop file, save the location
      # and break the loop. The substring operation here
      # get's the last field of a path:
      # ie : /path/to/file.extention -> file.extension
      if [ "${deskf##*/}" = "$WANTDESKTOPFILE" ]
      then
        DESKTOPFILE="$(echo "$deskf" | grep "$WANTDESKTOPFILE")"
        break 2
    fi
    done
  done

  # if we still havent found the proper desktop file, we now need to search
  # for a desktop file that can handle the file's mimetype
  [ -z "$DESKTOPFILE" ] && {
  # for each directory that desktop files exist
  for DESKDIR in $USER_DESKTOP_FILES_DIR $SYSTEM_DESKTOP_FILES_DIR
  do
    # for every desktop file in those directories
    for deskf in "$DESKDIR"*
    do
      # if the desktop file contains the mimetype
      if grep -q "$MIME_TYPE" "$deskf"
      then
        # set the desktop file to be our matched one
        DESKTOPFILE="$deskf"
        break 2
      fi
    done
  done
  }
  # open the file according to how the desktop file specifies; we replace
  # the equal sign with a tilde because base64 uses equal signs for padding
  execcmd="$(grep "^Exec=" "$DESKTOPFILE" \
    | tr '=' '~' \
    | sed \
    "s~%[fFuU]~\"\$(echo $(printf "%s" "${f}" | base64 -w 0) | base64 -d)\"~")"
  # use a substring command to get just the command
  execcmd="${execcmd#*~}"
  }

  # if we haven't created an execcmd and the file exists
  [ -z "$execcmd" ] && [ -e "$REGEXRULESFILE" ] && {
  # for every regex rule that is definied the regex rules file
  # shellcheck disable=SC2013
  for rerule in $(grep -v -E "(^#|^$)" "$REGEXRULESFILE" | cut -d'	' -f1)
  do
    # if we get a match on the input
    if printf "%s" "$f" | grep -q -E "$rerule"
    then
      # create our exec command using the second field in the TSV
      execcmd="$(grep -F "${rerule}" "$REGEXRULESFILE" \
        | cut -d'	' -f2 \
        | sed \
        "s~%M~\"\$(echo $(printf "%s" "${f}" | base64 -w 0) | base64 -d)\"~g")"
      break
    fi
  done
  }

  # we use 'sh' here instead of 'exec' because shell is much more powerful
  # than 'exec'. This is to allow people to write full fleged shell scripts
  # in their configuration files for shopen.
  sh -c "$execcmd" &
done
wait
